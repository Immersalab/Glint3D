<!-- Machine Summary Block -->
{"file":"ai/tasks/glint_cli_platform_v1/artifacts/documentation/config_precedence_and_settings.md","purpose":"Defines configuration layers, precedence rules, and merge semantics for Glint CLI v1.","exports":["config_layers","merge_algorithm","environment_contract"],"depends_on":["ai/tasks/glint_cli_platform_v1/task.json","ai/tasks/glint_cli_platform_v1/artifacts/documentation/cli_product_spec.md"],"notes":["flags_override_lower_layers","deterministic_merge","workspace_scopes"]}
<!-- Human Summary -->
Design note covering how CLI flags, manifests, workspace files, and environment variables resolve into final settings for deterministic runs.

# Configuration Precedence and Settings Resolution

## 1. Goals
- Provide a deterministic, inspectable path from user intent to resolved settings.
- Allow studios to enforce baseline policies while empowering per-command overrides.
- Support non-interactive usage (CI) and local iteration with the same layering model.

## 2. Layers and Precedence
Resolution order from highest to lowest priority (later layers only consulted if higher ones omit a value):

| Priority (High to Low) | Layer | Scope | Storage | Notes |
| --- | --- | --- | --- | --- |
| 1 | CLI flag (`--set`, explicit verb options) | Per invocation | argv | Always wins. `--set key=value` applies to any namespaced key. Verb-specific flags (for example `--device gpu`) map into normalized keys before merge. |
| 2 | Command context defaults | Per invocation | in-memory | Derived values such as `glint render --frames` expanding to `render.frames`. |
| 3 | Project manifest overrides | Per scene / target | `glint.project.json` (`configuration.overrides`) | Keys keyed by logical target (for example scene id). |
| 4 | Project manifest defaults | Project | `glint.project.json` (`configuration.defaults`) | Baseline authored defaults checked into source control. |
| 5 | Workspace config | Workspace | `.glint/config.json` | Maintained by artists; can be generated by `glint config`. |
| 6 | Environment variables | Machine/user | process environment | `GLINT_<SECTION>__<KEY>` double underscore acts as dot separator (for example `GLINT_RENDER__DEVICE=gpu`). |
| 7 | Global config | Machine | `%APPDATA%/Glint3D/config.json` on Windows, `$XDG_CONFIG_HOME/glint/config.json` or `~/.config/glint/config.json` elsewhere | Optional; enables lab-wide defaults. |
| 8 | Built-in defaults | Binary | compiled constants | Provide sensible fallbacks when nothing else supplies a value. |

Layer metadata:
- Each layer is tagged with `source`, `path`, `timestamp` for audit logs.
- CLI exposes `glint config --explain <key>` to output the stack and winner.

## 3. Data Model
- Settings keys use dotted namespaces (`render.samples`, `assets.cache_dir`).
- Values may be scalar, arrays (lists), or objects (maps). Merge rules differ by type.
- Supported primitives: string, number, boolean. Complex types (arrays/objects) must be JSON-compatible.

## 4. Merge Semantics
1. Start with empty configuration.
2. Walk layers from lowest to highest priority, applying merges:
   - Scalars: higher layer replaces lower layer.
   - Arrays: default behavior is replacement; flags may opt into additive merges via `--set render.outputs+=normals`.
   - Objects: deep merge, but higher layer wins conflicts on the same key.
3. Keep provenance for each resolved key (list of `{layer, value, effective}` records).
4. After applying all layers, run validators (for example type checks, range enforcement).

### 4.1 Merge Algorithm (Pseudocode)
```pseudo
function resolve_settings(request):
    merged = {}
    provenance = {}
    for layer in LAYERS_LOW_TO_HIGH:
        payload = load_layer(layer, request)
        for key, value in payload.items():
            merged[key], provenance[key] = merge_value(
                current=merged.get(key),
                incoming=value,
                existing_prov=provenance.get(key),
                layer=layer
            )
    validate(merged)
    return merged, provenance
```

`merge_value` performs type reconciliation, array replacement rules, and records provenance.

## 5. Configuration Files

### 5.1 `.glint/config.json`
```json
{
  "render": {
    "device": "auto",
    "samples": 32,
    "denoise": false
  },
  "assets": {
    "cache_dir": "cache/assets",
    "mirror": "https://assets.example.com"
  }
}
```

### 5.2 Global Config
Mirror workspace config but stored under the user's profile. Keys absent in workspace fall back to global values.

### 5.3 Environment Variables
- Pattern: `GLINT_<SECTION>__<KEY>=value`.
- CLI normalizes names to lower-case dotted keys.
- Booleans accept `1/0`, `true/false`, `yes/no`.

## 6. CLI Integration
- `glint config --get render.samples` prints the resolved value plus provenance trail.
- `glint config --scope workspace --set render.samples=128` writes to `.glint/config.json` with deterministic formatting (sorted keys, LF endings).
- `glint config --reset render.samples` removes the key from the chosen scope.
- `glint config --explain render.samples --json` emits NDJSON rows describing each contender.

## 7. Determinism and Caching
- Resolved settings cached in memory per invocation, not persisted.
- For long-running sessions (watch mode), watchers detect file changes and re-resolve.
- Provenance data stored in run manifest under `settings.provenance` when `--json` is active.

## 8. Extension Points
- Future layers (for example studio policy service) can be inserted by registering a new layer with priority between environment and global config.
- Merge strategy can be extended per key (for example `modules.enabled` additive merges) using a registry keyed by prefix.

## 9. Validation Rules
- Unknown keys trigger warnings in `glint config --validate` and hard errors when `--strict` is set.
- Type mismatches bubble up as `SchemaValidationError`.
- Circular dependencies (for example `render.device` referencing another key via template) are not supported in v1.

---
Ownership: Platform Team - Milestone A (CLI Platform v1)
